括号生成
==

## 1. 题目链接

[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

## 2. 解题思路

### 2.1 暴力解法

> 1. 生成所有括号序列；
> 2. 判断括号序列是否是有效的；
> 
> 如何生成括号序列？
> 1. 借助`algorithm`库里的`next_permutation`函数；
> 2. 递归生成：
> 其实就是2n个小括号排列组合，第一个位置的括号确定之后，只有后面2n-1和位置的括号也确定即可生成一个括号序列
> 子问题和原问题具有相同的结构，完美的递归定义

### 2.2 暴力解法C++代码实现

```c++
#if 0
// 解法一：暴力枚举
// 1. 生成所有括号序列；
// 2. 判断括号序列是否合法；
// 3. 统计合法括号序列；
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        std::vector<std::string> ret;
        // 参数检查
        if (n <= 0) {
            return ret;
        }
        std::string s;
        s.resize(2*n);
        for (int i = 0; i < 2*n; i += 2) {
            s[i] = '(';
            s[i+1] = ')';
        }
        // 这里sort的原因是让输出的结果和标准答案一样
        // 不知道判题会不会有顺序不同而导致结果不同，所以这里排序了一下
        std::sort(s.begin(), s.end());
        // 这里借助算法库里的std::next_permutation来生成下一个序列
        do {
            // 判断是否合法
            if (isValid(s)) {
                ret.push_back(s);
            }
        } while(std::next_permutation(s.begin(), s.end()));
        return ret;
    }
private:
    bool isValid(const std::string& s) {
        // ()()()
        // 发现用这种方法来判断括号匹配要比用栈来判断括号匹配简单
        int balance = 0;
        for (auto c : s) {
            if (c == '(') {
                ++balance;
            } else {
                --balance;
            }
            if (balance < 0) {
                return false;
            }
        }
        return (balance == 0);
    }
};
#endif

#if 1
class Solution {
    bool isValid(const std::string& s) {
        int balance = 0;
        for (char c : s) {
            if (c == '(') {
                ++balance;
            } else {
                --balance;
                if (balance < 0) {
                    return false;
                }
            }
        }
        return balance == 0;
    }

    void generateAll(std::string& current, int n, std::vector<std::string>* result) {
        if (current.size() == n) {
            if (isValid(current))
                result->push_back(current);
            return;
        }
        current += '(';
        generateAll(current, n, result);
        current.pop_back();
        current += ')';
        generateAll(current, n, result);
        current.pop_back();
    }
public:
    vector<string> generateParenthesis(int n) {
        std::vector<std::string> result;
        if (n <= 0) {
            return ret;
        }
        std::string current;
        // 通过递归生成所有序列
        generateAll(current, n * 2, &result);
        return result;
    }
};

#endif

```
