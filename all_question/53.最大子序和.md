# 最大子序和
## 一、题目描述
> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

==题目链接==: [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
## 二、示例
### 1. 示例1
> **输入**: `[-2,1,-3,4,-1,2,1,-5,4]`
> **输出**: `6`
> **解释**: 连续子数组 `[4,-1,2,1]` 的和最大，为 `6`

## 三、进阶
如果你已经实现复杂度为$O(n)$的解法，尝试使用更为精妙的分治法求解。

## 四、解题经过
### 1. 蛮力枚举
 用三个`for`循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组和中最大的一个值

 令`currSum[i,···,j]`为数组`nums`中第`i`个元素到第`j`个元素的和(其中$0 \leq i \leq j \leq n$)，`maxSum`为最终求得的最大连续子数组的和。当全是负数时，可以让程序返回`0`，也可以让程序返回最大的那个负数。这里，让程序返回最大的那个负数。

 参考代码如下：
 ```c++
  class Solution {
  public:
      int maxSubArray(vector<int>& nums) {
          // 解法一： 蛮力枚举
          if(nums.empty())
          {
              return 0;
          }

          int maxSum = nums[0]; // 注意这里的赋值不要给成0 考虑一下数组全为负数的情况
          int currSum = 0;
          int n = static_cast<int>(nums.size());
          for(int i = 0; i < n; ++i)
          {
              for(int j = i; j < n; ++j)
              {
                  for(int k = i; k <= j; ++k)
                  {
                      currSum += nums[k];
                  }
                  if(currSum > maxSum)
                  {
                      maxSum = currSum;
                  }

                  // 这里要记得清零，否则 sum 最终存放的是所有子数组的和
                  currSum = 0;
              }
          }

          return maxSum;
      }
  }; 
 ```
 但是很遗憾，这个解法在`LeetCode`上`超出时间限制`，因为此解法的时间复杂度是$O(n^3^)$。
 我们考虑一下其他的解法吧

