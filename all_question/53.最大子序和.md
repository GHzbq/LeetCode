# 最大子序和
## 一、题目描述
> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

==题目链接==: [最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
## 二、示例
### 1. 示例1
> **输入**: `[-2,1,-3,4,-1,2,1,-5,4]`
> **输出**: `6`
> **解释**: 连续子数组 `[4,-1,2,1]` 的和最大，为 `6`

## 三、进阶
如果你已经实现复杂度为$O(n)$的解法，尝试使用更为精妙的分治法求解。

## 四、解题经过
### 1. 蛮力枚举
 用三个`for`循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组和中最大的一个值

 令`currSum[i,···,j]`为数组`nums`中第`i`个元素到第`j`个元素的和(其中$0 \leq i \leq j \leq n$)，`maxSum`为最终求得的最大连续子数组的和。当全是负数时，可以让程序返回`0`，也可以让程序返回最大的那个负数。这里，让程序返回最大的那个负数。

 参考代码如下：
 ```c++
  class Solution {
  public:
      int maxSubArray(vector<int>& nums) {
          // 解法一： 蛮力枚举
          if(nums.empty())
          {
              return 0;
          }

          int maxSum = nums[0]; // 注意这里的赋值不要给成0 考虑一下数组全为负数的情况
          int currSum = 0;
          int n = static_cast<int>(nums.size());
          for(int i = 0; i < n; ++i)
          {
              for(int j = i; j < n; ++j)
              {
                  for(int k = i; k <= j; ++k)
                  {
                      currSum += nums[k];
                  }
                  if(currSum > maxSum)
                  {
                      maxSum = currSum;
                  }

                  // 这里要记得清零，否则 sum 最终存放的是所有子数组的和
                  currSum = 0;
              }
          }

          return maxSum;
      }
  }; 
 ```
 但是很遗憾，这个解法在`LeetCode`上`超出时间限制`，因为此解法的时间复杂度是$O(n^{3})$。
 我们考虑一下其他的解法吧

### 2. 动态规划
 事实上，可以令`currSum`是以当前元素结尾的最大连续子数组的和，`maxSum`是全局的最大子数组的和，当往后扫描时，对第`j`个元素有两种选择，要么放到前面找到的子数组，要么作为新子数组的第一个元素：如果`currSum`>0，则令`currSum`加上`a[j]`；如果`currSum`<0，则`currSUm`被置为当前元素，即`currSum=a[j]`.
 这相当于说，如果设`currSum(j)`为以`j`结尾的最大连续子数组的和，那么`currSum[j]=max{0, currSum[j-1]}+a[j]`. 如果`maxSum<currSum`, 则更新`maxSum=currSum`; 否则`maxSum`保持原值，不更新.
 举个例子，如果输入数组是`{1, -2, 3, 10, -4, 7, 2, 5}`, 那么`currSum`和`maxSum`的变化为：
    `currSum: 0 -> 1 -> 1 -> 3 -> 13 -> 9  -> 16 -> 18 -> 13`
    `maxSum : 0 -> 1 -> 1 -> 3 -> 13 -> 13 -> 16 -> 18 -> 18`
 参考代码如下：
 ```c++
 class Solution {
 public:
     int maxSubArray(vector<int>& nums) {
         // 动态规划
         if(nums.empty())
         {
             return 0;
         }

         int n = static_cast<int>(nums.size());
         int currSum = 0;
         int maxSum = nums[0]; // 数组元素全为负的情况，返回最大数

         for(int j = 0; j < n; ++j)
         {
             if(currSum >= 0)
             {
                 currSum += nums[j];
             }
             else
             {
                 currSum = nums[j];
             }
             if (currSum > maxSum)
             {
                 maxSum = currSum;
             }
         }

         return maxSum;
     }
 };
```
 此方法从前往后扫描一遍数组，即完成求最大连续子数组和的需求，所以时间复杂度为$O(n)$。

## 五、问题变形
1. 如果要求出最大连续子数组的和，同时要求输出所求子数组的开始位置和结束位置呢？
2. 如果要求出最大子数组的和，但不要求子数组连续呢？
3. 如果数组是二维数组，同样要求出最大连续子数组的和呢？
4. 如果要求出连续子数组的最大乘积呢？

## 六、举一反三
### 1. 长度最长的连续子序列
 有一个有`n`个正整数组成的序列，现给定一个整数`S`，要求出序列中长度最短的一个连续子序列，要求满足其和大于等于`S`的条件。
 **解析**：可以直接用两个`for`循环枚举子序列的起点和终点，但这种方法的时间复杂度为O(n^3^)，需要找到更好的办法。

### 2. 最大子矩阵和
 给定一个`M`$\times$`N`的矩阵，找出此矩阵的一个子矩阵，要求满足这个子矩阵的元素的和是最大的，输出这个最大的值。如果所有数都是负数，就输出0.
 例如，给定一个 4\*4的矩阵：
$${}
\begin{matrix}
    0 & -2 & -7 & 0 \\
    9 & 2 & -6 & 2 \\
    -4 & 1 & -4 & 1 \\
    -1 & 8 & 0 & -2 \\
    \end{matrix}
$${}
 它的和最大的子矩阵是：
$${}
\begin{matrix}
    9 & 2 \\
    -4 & 1 \\
    -1 & 8 \\
    \end{matrix}
$${}
 最后输出的和的最大值为15.

### 3. 环面上的最大和
 给定一个被整数填满的网格，然后把网格的第一行和最后一行遮住，第一列和最后一列也遮住，得到一个环面，求此环面上的最大字矩形（即所有元素之和最大的子矩形）.

### 4. 最大子数组和的增强版
 给定一个数组，允许交换数组中任意两个数的位置，求最大子数组的和.
